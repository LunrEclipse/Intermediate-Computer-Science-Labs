// makeDataFiles.cpp// This program will generate data files as in file10.txt, file20.txt, etc./* The id values generated in these data files will be unique.  A hashing scheme will	be used to store the id/inv pairs and to check for repeats.  Another advantage of this	scheme is that the pairs will be in random order when sent to the disk.  This random	order of id values will be necessary when testing future algorithms such as linked list	and binary tree insertion algorithms */	#include <iostream.h>#include <fstream.h>#include <iomanip.h>#include <apvector.h>#include <bool.h>#include <apstring.h>#include <dice.h>const int SIZEOFTABLE = 1000;struct listNode{	int  id;	int  inv;	listNode *next;};int hash (long);void hashIt (apvector<listNode*> &, int, int, bool&);void fillVector (apvector<listNode*> &, int&);void saveFile (const apvector<listNode*> &, int);main(){	apvector<listNode*> table(SIZEOFTABLE,NULL);	int howMany;	// howMany items the user wishes to generate		fillVector (table, howMany);	saveFile (table, howMany);	return 0;}void fillVector(apvector<listNode*> &table, int &howMany){	int largestId, largestInv, tempId, tempInv, count=0;	apstring fileName;	ofstream outFile;	bool duplicate;			cout << "How many items do you wish to generate ---> ";	cin >> howMany;	cout << "What is the largest Id value you wish to generate ---> ";	cin >> largestId;	cout << "What is the largest Inventory value you wish to make ---> ";	cin >> largestInv;	dice idDie (largestId);	dice invDie (largestInv);	cin.get();		// dump return key	cout << endl << "Generating data" << endl;	while (count < howMany)	{		tempId = idDie.roll();		tempInv = invDie.roll();		hashIt (table, tempId, tempInv, duplicate);		if (!duplicate) 			count++;		if (count % 50 == 0)			cout << "*";	}}void hashIt (apvector<listNode*> &table, int tempId, int tempInv, bool &duplicate){	int position;	// position in hash table	listNode *newNode, *temp;	bool match = false;		position = hash (tempId);	// get position where tempId could be stored	temp = table[position];		//	start temp at spot in hash table	while ((temp != NULL) && (temp->id != tempId))	// traverse unordered linked lists		temp = temp->next;	if ((temp != NULL) && (temp->id == tempId))		match = true;	if (match)		// id value already exists in hash table		duplicate = true;	else	// add new item to hash table	{							newNode = new listNode;		newNode->id = tempId;		newNode->inv = tempInv;		newNode->next = table[position];		// stick at front of list		table[position] = newNode;				// rejoin list to newNode		duplicate = false;	}}int hash (long keyId){	const int MODULUS = 1999;	// a large prime number	const int MULTIPLIER = 273;	const int INCREMENT = 59;		long temp;		temp = (MULTIPLIER * keyId) + INCREMENT;	temp = temp % MODULUS;	return (temp % SIZEOFTABLE);}void saveFile (const apvector<listNode*> &table, int howMany){	int loop;	listNode *temp;	apstring fileName;	char* cFile;	ofstream  outFile;		cout << "Enter name of file to save as ---> ";	getline(cin,fileName);	cFile = fileName.c_str();	cout << cFile << endl;	outFile.open(cFile);	outFile << howMany << endl;	for (loop=0; loop<SIZEOFTABLE; loop++)	{			temp = table[loop];		while (temp != NULL)		{			outFile << setw(10) << temp->id << setw(10) << temp->inv << endl;			temp = temp->next;		}	}}