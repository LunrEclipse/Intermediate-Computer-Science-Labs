// kTour.cpp// Cary Matsuoka/* This program will start the knight chess piece at a corner of the	board and attempt to move to all 64 squares.  This first program	will use a random number generator to attempt a move of type 1-8.	The possible moves are categorized as follows:	move 1:  +1 to the right, -2 up, a negative move to go up in the grid	move 2:  +2 to the right, -1 up	move 3:  +2 to the right, +1 down	move 4:  +1 to the right, +2 down	move 5:  -1 to the left, +2 down	move 6:  -2 to the left, +1 down	move 7:  -2 to the left, -1 up	move 8:  -1 to the left, -2 up	The program will move the knight until all 64 squares have been	hit (extremely rare), or the piece gets stuck.  The program will	print out the board, with numbers ranging from 1-64 for the order	in which the squares were visited. */#include <iostream.h>#include <dice.h>#include <iomanip.h>#include <apvector.h>#include <apmatrix.h>#include <bool.h>void initHoriz (apvector<int> &);void initVert (apvector<int> &);bool validMove (int, int, int, const apmatrix<int> &);void printBoard (const apmatrix<int> &);void initCheckList (apvector<int> &);bool triedAll8Dir (const apvector<int> &);int doTour (apmatrix<int> &);// Global vectors are used to calculate moves.  I decided to make these global vectors// because they are used in so many places in the program and the parameter lists// were getting long.apvector<int> horizMove(9), vertMove(9);/* The vector horizMove contains the horizontal movement necessary to move to a new   location.  These values will ultimately be added to a column location.  Likewise    the vector vertMove will be used to make vertical moves, which will adjust the   row location. */void main (){	apmatrix<int> board(9,9,0);	int howFar;		initHoriz (horizMove);	initVert (vertMove);	howFar = doTour (board);	printBoard (board);	cout << endl << howFar << " squares were completed" << endl;}void initHoriz (apvector<int> &h)// Used to adjust horizontal position.{	h[1] = 1;  	h[2] = 2; 	h[3] = 2;  	h[4] = 1;	h[5] = -1;  	h[6] = -2;  	h[7] = -2;  	h[8] = -1;}void initVert (apvector<int> &v)// Used to adjust vertical position{	v[1] = -2;  // go up 2, see diagram on lab sheet	v[2] = -1;  // go up 1	v[3] = 1;	// go down 1	v[4] = 2;	// go down 2	v[5] = 2;	// etc.	v[6] = 1;	v[7] = -1;	v[8] = -2;}bool validMove (int row, int col, int move, const apmatrix<int> &board)/* row and col are a position on the board, move is the potential move we are   investigating.  If the move is legal (on the board and not already taken) we   return true, otherwise false.	Solves for a valid move with 3 steps:		1.  finds potential new location		2.  checks to see if that location is on the board		3.  if on the board, checks to see if square is empty  */{	bool valid = true;	// start out assuming valid state	int newRow, newCol;	newRow = row + vertMove[move];  // vertical move changes the row number	newCol = col + horizMove[move]; // horizontal move changes the col number	if (newRow < 1 || newRow > 8 || newCol < 1 || newCol > 8)		valid = false;	else if (board[newRow][newCol] != 0)		valid = false;	return valid;}void printBoard (const apmatrix<int> &board){	int row,col;	cout << setiosflags(ios::right);	cout << "     ";	// 5 spaces	for (row=1; row<=8; ++row)		cout << setw(5) << row;	cout << endl << endl;	for (col=1; col<=8; ++col)	{		cout << setw(5) << col;		for (row=1; row<=8; ++row)			cout << setw(5) << board[row][col];		cout << endl;	}}void initCheckList (apvector<int> &checkList){	for (int loop=1; loop<=8; loop++)		checkList[loop] = 0;}bool triedAll8Dir (const apvector<int> &list)/* list will contain true/false values in positions 1..8.  list[0] will	not be used.  If all 8 bits are true, all 8 directions have been	tried and the function returns true, otherwise it returns false. */{	bool tryAll = true;	// assume that all 8 bits are true	for (int loop=1; loop<=8; ++loop)		if (!list[loop]) tryAll = false;	return tryAll;}int doTour (apmatrix<int> &board)/* Precondition:  board has been initialized to all 0's.	Will attempt a knight's tour around the board.  The piece will start	at row 1, col 1.  The function will return the last numbered position	reached on the board. */{	bool done = false;	int row=1, col=1, number=1, move;  // row and col start at (1,1)	apvector<int> checkList(9,0);	// checkList initialized with all 0's	dice die(8);  // create an 8-sided die		board[1][1] = 1;  // gets the board started	while (!done)	{		move = die.roll();		if (validMove(row,col,move,board))		{			number++;			row = row + vertMove[move];  // go to new row			col = col + horizMove[move]; // go to new col			board[row][col] = number;			initCheckList (checkList);	 // clean off list, start over			if (64 == number) done = true;		}		else  // move did not work		{			checkList[move] = true;			if (triedAll8Dir(checkList))				done = true;		}	}	// while !done	return (number);}