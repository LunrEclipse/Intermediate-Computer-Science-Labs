// kTour2.cpp// Cary Matsuoka/*  This program will start the knight chess piece at a location chosen by	the user and attempt to move to all 64 squares.  This second program	will use the accessibility heuristic as suggested by Deitel.	The possible moves are categorized as follows:	move 1:  +1 to the right, -2 up, a negative move to go up in the grid	move 2:  +2 to the right, -1 up	move 3:  +2 to the right, +1 down	move 4:  +1 to the right, +2 down	move 5:  -1 to the left, +2 down	move 6:  -2 to the left, +1 down	move 7:  -2 to the left, -1 up	move 8:  -1 to the left, -2 up */#include <iostream.h>#include <iomanip.h>#include <fstream.h>#include <apvector.h>#include <apmatrix.h>#include <bool.h>#include <apstring.h>#include <stdlib.h>const apstring SOURCE = "c:\\ap98\\access.txt";// Global vectors, used to calculate moves.  I decided to make these global vectors// because they are used in so many places in the program and the parameter lists// were getting long.apvector<int> horizMove(9), vertMove(9);/* The vector horizMove contains the horizontal movement necessary to move to a new   location.  These values will ultimately be added to a column location.  Likewise    the vector vertMove will be used to make vertical moves, which will adjust the   row location. */// functions from ktour1.cppvoid initHoriz (apvector<int> &);void initVert (apvector<int> &);bool validMove (int, int, int, const apmatrix<int> &);void printBoard (const apmatrix<int> &);void initCheckList (apvector<int> &);// functions modified from ktour1.cppint doTour (apmatrix<int> &, int, int);// new functions for ktour2.cppvoid initAccessGrid (apmatrix<int> &);void getAccessList (const apmatrix<int> &, int, int,					const apmatrix<int> &, apvector<int> &);int getBestMove (const apvector<int> &);void upDateAccess (apmatrix<int> &, int, int);bool finishOff (apmatrix<int> &,int,int);void main (){	int howFar, rowStart, colStart;	apmatrix<int> board(9,9,0);	initHoriz (horizMove);  // initialize global vectors	initVert (vertMove);	cout << "Enter starting row coordinate ---> ";	cin >> rowStart;	cout << "Enter starting col coordinate ---> ";	cin >> colStart;	howFar = doTour (board,rowStart,colStart);	cout << setw(5) << howFar << endl << endl;	printBoard (board);}void initHoriz (apvector<int> &h)// Used to adjust horizontal position.{	h[1] = 1;  	h[2] = 2; 	h[3] = 2;  	h[4] = 1;	h[5] = -1;  	h[6] = -2;  	h[7] = -2;  	h[8] = -1;}void initVert (apvector<int> &v)// Used to adjust vertical position{	v[1] = -2;  // go up 2, see diagram on lab sheet	v[2] = -1;  // go up 1	v[3] = 1;	// go down 1	v[4] = 2;	// go down 2	v[5] = 2;	// etc.	v[6] = 1;	v[7] = -1;	v[8] = -2;}bool validMove (int row, int col, int move, const apmatrix<int> &board)/* row and col are a position on the board, move is the potential move we are   investigating.  If the move is legal (on the board and not already taken) we   return true, otherwise false.	Solves for a valid move with 3 steps:		1.  finds potential new location		2.  checks to see if that location is on the board		3.  if on the board, checks to see if square is empty  */{	bool valid = true;	// start out assuming valid state	int newRow, newCol;	newRow = row + vertMove[move];  // vertical move changes the row number	newCol = col + horizMove[move]; // horizontal move changes the col number	if (newRow < 1 || newRow > 8 || newCol < 1 || newCol > 8)		valid = false;	else if (board[newRow][newCol] != 0)		valid = false;	return valid;}void printBoard (const apmatrix<int> &board){	int row,col;	cout << setiosflags(ios::right);	cout << "     ";	// 5 spaces	for (row=1; row<=8; ++row)		cout << setw(5) << row;	cout << endl << endl;	for (col=1; col<=8; ++col)	{		cout << setw(5) << col;		for (row=1; row<=8; ++row)			cout << setw(5) << board[row][col];		cout << endl;	}}void initCheckList (apvector<int> &checkList){	for (int loop=1; loop<=8; loop++)		checkList[loop] = 0;}int doTour (apmatrix<int> &board,int rowStart, int colStart)/*  Precondition:  board has been initialized to all 0's.	Will attempt a knight's tour around the board.  The piece will start	at rowStart, colStart.  The function will return the last numbered position	reached on the board. */{	int  move, row=rowStart, col=colStart;	apmatrix<int>  access(9,9);	apvector<int> list(9,0);		// initialized to all 0's	int  number = 1, dummy;	bool done = false;	board[row][col] = number;	initAccessGrid (access);	upDateAccess (access,row,col);  // do the first round of subtractions	while (!done)	{		getAccessList (board,row,col,access,list);		move = getBestMove (list);		if (move > 0)  // this is a possible move		{			number++;			row += vertMove[move];			col += horizMove[move];			board[row][col] = number;			upDateAccess (access,row,col);			if (number == 63) done = true;  // not 64 as you would expect, see finishOff		}		else			done = true;	}	if (number == 63)		if (finishOff(board,row,col))			number = 64;	return (number);}void initAccessGrid (apmatrix<int> &temp)/* Read initial access data from disk */{	ifstream infile;	int  row, col;   infile.open(SOURCE.c_str());   if (infile.fail())   {   	cerr << "Could not open " << SOURCE << endl;      abort();   }	for (row=1; row<=8; row++)   {		for (col=1; col<=8; col++)		{      	infile >> temp[row][col];      }   }}void getAccessList (const apmatrix<int> &board, int row, int col,					const apmatrix<int> &access, apvector<int> &list)/*  Takes in current row/col position and board.  list is uninitialized.	Will return the list of 8 accessibility values which are potential moves.	If a move(1..8) is available, that value in list[1..8] will return the	accessibility of the cell that would be moved to.  If the move is not valid,	that value if list[1..8] will be 0.  */{	int move, newRow, newCol;	initCheckList (list);	for (move=1; move<=8; ++move)		if (validMove (row,col,move,board))		{			newRow = row + vertMove[move];			newCol = col + horizMove[move];			list[move] = access[newRow][newCol];		}}int getBestMove (const apvector<int> &list)/*  uses info in list, containing access values for each direction	(1..8).  Determines out of the potential moves which one	moves toward a square with the lowest accessibility.  It will return	the lowest first move. If there is a tie, it will return the smaller	move value.  If all values in the list are <= 0, the function	returns 0  */{	int lowestMove, lowestAccess, move;	lowestMove = 0; 	// set to no move, initially	lowestAccess = 10;  // set to arbitrarily high state	for (move=1; move<=8; ++move)	{		if ((0 < list[move]) && (list[move] < lowestAccess))		{			lowestMove = move;			lowestAccess = list[move];		}	}	return (lowestMove);}void upDateAccess (apmatrix<int> &access, int row, int col)/*  takes in access grid, row and col are the coordinates of the latest	square to be marked.  We now need to check all 8 moves and decrease	any appropriate accessibility numbers by -1.  As we check all 8 moves	we must first check for a valid move (on the grid).  This algorithm	will allow accessibility numbers to go negative. */{	int newRow, newCol, move;	for (move=1; move<=8; ++move)	{		newRow = row + vertMove[move];		newCol = col + horizMove[move];		if ( ! ((newRow < 1) || (newRow > 8) || (newCol < 1) || (newCol > 8)))			access[newRow][newCol]--;	}}bool finishOff (apmatrix<int> &board, int row, int col)/* This last function is needed to place the 64th number.  The	accessibility of the last square reads 0 after numbers 1-63 have	been placed.  Returns 1 if successful, 0 if unsuccessful*/{	int move;	bool success = false;	for (move=1; move<=8; ++move)	{		if (validMove(row,col,move,board))		{			row += vertMove[move];			col += horizMove[move];			board[row][col] = 64;	// Hooray!  10/12/95			success = true;		}	}	return (success);}