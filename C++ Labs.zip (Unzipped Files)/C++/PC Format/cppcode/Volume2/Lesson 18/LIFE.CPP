/* life.cppThis program will simulate the game of Life as described in themathematical model by Conway.  The program will read a text filecontaining the initial grid of bacteria.  The program will thenproceed for 5 generations and print answers.The identifiers used in this program are taken from the bacteriologylab room.  A petri dish is used to culture and study bacteria growth.To innoculate means to expose a sterile petri dish to bacteria.  */#include <iostream.h>#include <iomanip.h>#include <fstream.h>#include <apmatrix.h>#include <apstring.h>#include <stdlib.h>const apstring SOURCE = "c:\\ap98\\life100.txt";const int MAXROW = 22;	// matrices used will be 22 rows x 22 colsconst int MAXCOL = 22;  // rows 0..21 and columns 0..21void innoculate (apmatrix<int> &dish);void screenDump (const apmatrix<int> &temp);int countLiving (const apmatrix<int> &temp);int countRow (const apmatrix<int> &temp, int row);int countCol (const apmatrix<int> &temp, int col);void addNeighbors (apmatrix<int> &temp, int r, int c);void lifeOrDeath (apmatrix<int> &mainDish, const apmatrix<int> &dataDish);void nextGen (apmatrix<int> &mainDish);void main (){	int loop;	apmatrix<int> petriDish(22,22,0);	// initialize all values to 0	innoculate (petriDish);	for (loop=1; loop<=5; loop++)		nextGen (petriDish);	screenDump (petriDish);	cout << endl << endl;	cout << "Total alive in row 10 = " << countRow (petriDish,10) << endl;	cout << "Total alive in col 10 = " << countCol (petriDish,10) << endl;	cout << "Total alive in petriDish = " << countLiving (petriDish) << endl;}void innoculate (apmatrix<int> &dish){	ifstream  infile;	int  loop, howmany, r, c;   infile.open(SOURCE.c_str());   if (infile.fail())   {   	cerr << "Could not open " << SOURCE << endl;      abort();   }	infile >> howmany;   cout << howmany << endl;	for (loop=1; loop<=howmany; loop++)	{		infile >> r >> c;		dish [r][c] = 1;	}}void screenDump (const apmatrix<int> &temp){	int row,col;	cout << setiosflags (ios::right);	cout << "       12345678901234567890" << endl << endl;	for (row=1; row<=20; row++)	{		cout << setw(2) << row << "     ";  // 5 blanks		for (col=1; col<=20; col++)		{			if (temp[row][col]) cout << "*";			else cout << " ";		}		cout << endl;	}}int countLiving (const apmatrix<int> &temp){	int  row,col,count=0;	for (row=1; row<=20; row++)		for (col=1; col<=20; col++)			if (temp[row][col])				count++;	return (count);}int countRow (const apmatrix<int> &temp, int row){	int col, count=0;	for (col=1; col<=20; col++)		if (temp[row][col])			count++;	return (count);}int countCol (const apmatrix<int> &temp, int col){	int row, count=0;	for (row=1; row<=20; row++)		if (temp[row][col])			count++;	return count;}void addNeighbors (apmatrix<int> &temp, int r, int c)/* adds 1 to each neighbor in all 8 directions.  This will put numbers in the border area   but the lifeOrDeath function will clean them up. */{	int  row,col;	for (row=r-1; row<=r+1; row++)		for (col=c-1; col<=c+1; col++)			temp[row][col]++;	temp[r][c]--;	// take away the 1 added to the middle cell}void lifeOrDeath (apmatrix<int> &mainDish, const apmatrix<int> &dataDish)/* dataDish has data to create next generation.  mainDish has previous	generation, will create next generation from dataDish.	If a value in dataDish == 3, then that location was empty, it	has 3 neighbors, bring it to life.	If a value in dataDish == 102 or 103, keep it alive.	All other values result in a dead spot. */{	int r, c;	for (r=1; r<=20; r++)		for (c=1; c<=20; c++)			if (3 == dataDish[r][c])				mainDish[r][c] = 1;			else if ((102==dataDish[r][c]) || (103==dataDish[r][c]))				mainDish[r][c] = 1;			else				mainDish[r][c] = 0;}void nextGen (apmatrix<int> &mainDish)/* mainDish will be an alias for petriDish in function main.	A local dataDish will be created within nextGen.  Every cell in	mainDish will be analyzed for life(1) or death(0).  If a cell is	alive, a 100 will be assigned to the corresponding cell in dataDish	and all 8 of its neighbors will be incremented +1 in tempDish.  The	data in dataDish will be studied in lifeOrDeath to determine who	lives or dies in the next mainDish. */{	apmatrix<int> dataDish(MAXROW,MAXCOL,0);  // starts with all 0's	int row, col;	for (row=1; row<=20; row++)		for (col=1; col<=20; col++)			if (mainDish[row][col])			{				addNeighbors (dataDish,row,col);				dataDish[row][col] += 100;			}	lifeOrDeath (mainDish, dataDish);}