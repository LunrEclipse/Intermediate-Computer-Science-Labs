// program threadTheMaze#include <iostream.h>#include <apmatrix.h>#include <fstream.h>#include <apstring.h>#include <stdlib.h>void loadTheMaze (apmatrix<char> &maze);void printMaze (const apmatrix<char> &maze);void traceMaze (apmatrix<char> maze, int row, int col);const int MAXROW = 12, MAXCOL = 12;const char BLANK = ' ';const apstring SOURCE = "c:\\ap98\\mazedata.txt";void loadTheMaze (apmatrix<char> &maze)/*	When reading text from disk, you cannot use the extraction operator,	>>, because it skips white space.  You need to use the stream member	function get, as used below.  You will also need to get rid of the	end-of-line marker, which is a single ASCII code 10 in C++ text file	processing. */{	ifstream inFile;	char c1;  // to dump end-of-line markers   inFile.open(SOURCE.c_str());   if (inFile.fail())   {   	cerr << "Could not open " << SOURCE << endl;      abort();   }	for (int row=1; row<=MAXROW; row++)	{		for (int col=1; col<=MAXCOL; col++)		{      	inFile.get(maze[row][col]);      }		inFile.get(c1);	// dump eoln marker, ASCII 10's	}}void printMaze (const apmatrix<char> &maze){	for (int row=1; row<=MAXROW; row++)	{		for (int col=1; col<=MAXCOL; col++)			cout << maze[row][col];		cout << endl;	}	cout << endl << "Hit return to continue ";	cin.get();}void traceMaze (apmatrix<char> maze, int row, int col)/*	will attempt to find a path out of the maze.  A path will be marked	with the ! marker.  The function uses value parameters so that only	the path out will be marked, otherwise extra ! markers will appear in	the answer.  The function is recursive. */{	if (1<=row && row<=MAXROW && 1<=col && col<=MAXCOL) 		// boundary check, if false, a base case	{		if (BLANK == maze[row][col])	// if false, base case		{			maze[row][col] = '!';			if (1==row || MAXROW==row || 1==col || MAXCOL==col)				printMaze (maze);  // base case			else			{				traceMaze (maze,row-1,col);				traceMaze (maze,row,col+1);				traceMaze (maze,row+1,col);				traceMaze (maze,row,col-1);			}		}	}}main (){	apmatrix<char> maze(MAXROW+1,MAXCOL+1);	loadTheMaze (maze);	traceMaze (maze,6,6);	return 0;}