//  mergesort.cppvoid merge(apvector<int> &a, int first, int mid, int last)/*  Takes in entire array, but will merge the following sections	together:  Left sublist from a[first]..a[mid], right sublist from	a[mid+1]..a[last].  Precondition:  each sublist is already in	ascending order */{	int aPtr=first, bPtr=mid+1, cPtr=first;	int total=last-first+1, loop;	bool doneA = false, doneB = false;	apvector<int> c(SIZE+1);	for (loop=1; loop<=total; loop++)	{		if (doneA)		{			c[cPtr] = a[bPtr];			bPtr++;		}		else if (doneB)		{			c[cPtr] = a[aPtr];			aPtr++;		}		else if (a[aPtr] < a[bPtr])		{			c[cPtr] = a[aPtr];			aPtr++;		}		else		{			c[cPtr] = a[bPtr];			bPtr++;		}		cPtr++;		if (aPtr > mid) doneA = true;		if (bPtr > last) doneB = true;	}	// for loop	for (loop=first; loop<=last; loop++)		a[loop] = c[loop];}void mergeSort (apvector<int> &a, int first, int last){	int mid;	if (first == last);	// empty case, only 1 value, do nothing	else		if (first+1 == last)	// list of 2 values, swap if necessary		{			if (a[first] > a[last])				swap (a[first],a[last]);		}		else	// general case		{			mid = (first+last) / 2;			mergeSort (a,first,mid);			mergeSort (a,mid+1,last);			merge (a,first,mid,last);		}}