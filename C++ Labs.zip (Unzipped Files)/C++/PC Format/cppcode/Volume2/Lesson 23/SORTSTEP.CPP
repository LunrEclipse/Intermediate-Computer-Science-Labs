// sortstep.cpp//  This source code has all the sorting algorithms with step analysis.#include <iostream.h>#include <iomanip.h>#include <dice.h>#include <apvector.h>#include <bool.h>// function prototypesvoid fillArray (apvector<int> &temp);void screenOutput (const apvector<int> &temp);void swap (int &a, int &b);void bubbleSort (apvector<int> &list);void selectionSort (apvector<int> &list);void insertionSort (apvector<int> &list);void merge(apvector<int> &a, int first, int mid, int last);void mergeSort (apvector<int> &a, int first, int last);void quickSort (apvector<int> &list, int first, int last);void sortMenu (apvector<int> &temp);long steps;  // global variable, to count # stepsconst int SIZE = 500;void fillArray (apvector<int> &temp)/* Asks the user for two inputs:	1.  the number of data to generate.	2.  the largest possible random integer to create.	Then proceeds to fill the array, from 1..number, where number	is stored in temp[0]. */{	int  loop, size;	cout << "How many numbers do you wish to generate? ";	cin >> temp[0];	cout << endl << "Largest integer to generate? ";	cin >> size;	dice die(size);	// allocate dice object	for (loop=1; loop<=temp[0]; loop++)		temp[loop] = die.roll();}void screenOutput (const apvector<int> &temp)// prints out the contents of the array in tabular form, 12 columns{	cout << setiosflags (ios::right) << endl;	for (int loop=1; loop<=temp[0]; loop++)	{		cout << setw(6) << temp[loop];		if (loop % 12 == 0) cout << endl;	}	cout << endl;}void swap (int &a, int &b){	int temp = a;	a = b;	b = temp;	steps+=3;}void bubbleSort (apvector<int> &list){	int outer,inner;	steps++;		// initialize outer=1	for (outer=1; outer <= list[0]-1; outer++)	{		steps+=3;  // outer loop boundary, outer++, initialize inner=1		for (inner=1; inner <= list[0]-outer; inner++)		{			steps+=3;  // boundary, inner++, if statement			if (list[inner] > list[inner+1])				swap(list[inner], list[inner+1]);		}	}}void selectionSort (apvector<int> &list){	int outer, inner, flag;	steps++;		// initialize outer=1	for (outer=1; outer < list[0]; outer++)	{		flag = outer;		steps+=4;  // outer boundary, outer++, flag=outer, inner=outer+1		for (inner=outer+1; inner<=list[0]; inner++)		{			steps+=3;  // inner boundary, inner++, if statement			if (list[inner] < list[flag])			{				steps++;  // flag=inner				flag = inner;			}		}		swap(list[outer], list[flag]);	}}void insertionSort (apvector<int> &list){	int outer, pos, temp;	steps++;		// initialize outer=2	for (outer=2; outer <= list[0]; outer++)	{		steps+=3;  // boundary, outer++, pos=outer		pos = outer;		temp = list[pos];	// move list[pos] out of list		while (pos > 1 && list[pos-1] > temp)		{			steps+=4;  // pos!=1, list[pos-1], > comparison, pos--			list[pos] = list[pos-1];			pos--;		}		list[pos] = temp;		steps++;	}}void merge(apvector<int> &a, int first, int mid, int last)/* Takes in entire array, but will merge the following sections	together:  Left sublist from a[first]..a[mid], right sublist from	a[mid+1]..a[last].  Precondition:  each sublist is already in	ascending order */{	int aPtr=first, bPtr=mid+1, cPtr=first;	int total=last-first+1, loop;	bool doneA = false, doneB = false;	apvector<int> c(SIZE+1);	steps+=7;  // 6 initializations above, loop=1	for (loop=1; loop<=total; loop++)	{		steps+=3;  // loop boundary, loop++, if		if (doneA)		{			steps+=2;  // assignment, bPtr++			c[cPtr] = a[bPtr];			bPtr++;		}		else if (doneB)		{			steps+=3;  // if, assignment, aPtr++			c[cPtr] = a[aPtr];			aPtr++;		}		else if (a[aPtr] < a[bPtr])		{			steps+=3;  // if, assignment, aPtr++			c[cPtr] = a[aPtr];			aPtr++;		}		else		{			steps+=2;  // assignment, bPtr++			c[cPtr] = a[bPtr];			bPtr++;		}		steps+=3;  // cPtr++, 2 if's		cPtr++;		if (aPtr > mid) doneA = true;		if (bPtr > last) doneB = true;	}	// for loop	steps++;		// initialize loop=first	for (loop=first; loop<=last; loop++)	{		a[loop] = c[loop];		steps+=3;	// loop boundary, loop++, assignment	}}void mergeSort (apvector<int> &a, int first, int last){	int mid;	steps++;  // if (first==last)	if (first == last);	// empty case, only 1 value, do nothing	else	{		steps++;		// if (first+1 == last)		if (first+1 == last)	// list of 2 values, swap if necessary		{			steps++;  // if (a[first] > a[last])			if (a[first] > a[last])				swap (a[first],a[last]);		}		else	// general case		{			steps++;  // assignment			mid = (first+last) / 2;			mergeSort (a,first,mid);			mergeSort (a,mid+1,last);			merge (a,first,mid,last);			// the function calls also require steps, but we won't count them		}	}}void quickSort (apvector<int> &list, int first, int last){	int g = first, h = last;	int midIndex, dividingValue, temp;	midIndex = (first + last) / 2;	dividingValue = list[midIndex];	steps+=4;  // 4 initialization statements	do	{		while (list[g] < dividingValue)		{			g++;			steps+=2;  // while boundary, g++		}		while (list[h] > dividingValue)		{			h--;			steps+=2;  // while boundary, h--		}		steps++;  // if (g <= h)		if (g <= h)		{			swap(list[g], list[h]);			g++;			h--;			steps+=2;  // g++, h--		}		steps++;  // (h > g)	}	while (h > g);	if (h > first) quickSort (list,first,h);	if (g < last) quickSort (list,g,last);	steps+=2;  // both if statements}void sortMenu (apvector<int> &temp){	char choice, print;	do	{		cout << "Sorting algorithm menu" << endl << endl;		cout << "(1) Bubble sort" << endl;		cout << "(2) Selection sort" << endl;		cout << "(3) Insertion sort" << endl;		cout << "(4) Recursive mergesort" << endl;		cout << "(5) Quicksort" << endl;		cout << "(6) Quit" << endl << endl;		cout << "Choice ---> ";		cin >> choice;		cin.get();	// to deal with return key		if ('1'<=choice && choice<='5')		{			fillArray(temp);			steps=0;			switch (choice)			{				case '1' : bubbleSort(temp); break;				case '2' : selectionSort(temp); break;				case '3' : insertionSort(temp); break;				case '4' : mergeSort(temp,1,temp[0]); break;				case '5' : quickSort(temp,1,temp[0]); break;			}			cout << endl << "Print list to screen (y/n)? ";			cin >> print;			cin.get();			if (print == 'y' || print == 'Y')				screenOutput(temp);			cout << endl << "# steps = " << steps << endl;			cout << endl << "Hit return to continue ";			cin.get();		}	}	while (choice != '6');}main(){	apvector<int> a(SIZE+1);	sortMenu(a);	return 0;}