// search.cpp#include <iostream.h>#include <apvector.h>#include <apstring.h>#include <bool.h>#include <iomanip.h>#include <stdlib.h>#include <fstream.h>const apstring SOURCE = "c:\\ap98\\file10.txt";struct item{	int id;	int inv;};struct storeType{	apvector<item> list;	int number;};void loadFile (apstring fileName, storeType &store);void printStore(const storeType &store);void testSearch (const storeType &store);int bsearch (const storeType &store, int idToSearch);int bsearch (const storeType &store, int idToSearch, int first, int last);void swap (item &a, item &b);void quickSort (apvector<item> &list, int first, int last);int sequentialSearch (const storeType &store, int idToSearch);	// for worksheet problemmain(){	storeType  store;	loadFile (SOURCE, store);	quickSort (store.list,0,store.number-1);	printStore (store);	testSearch (store);	return 0;}void loadFile (apstring fileName, storeType &store)//  precondition:  myList is uninitialized, will initialize myList with starting data//  I decided to put values directly into the data structure.  I did not use a separate//  addItem function as modeled in ages.cpp.{	ifstream in;	int loop;	char* tempName;	// we need to convert fileName to a char* string for in.open	tempName = fileName.c_str();	in.open(tempName);	in >> store.number;	store.list.resize (store.number);	for (loop=0; loop<store.number; loop++)		in >> store.list[loop].id >> store.list[loop].inv;}void printStore(const storeType &store){	int loop, line=1;	cout << setiosflags (ios::right);	cout << setw(15) << "Id" << setw(10) << "Inv" << endl << endl;	for (loop=0; loop<store.number; loop++)	{		cout << setw(5) << line;		cout << setw(10) << store.list[loop].id;		cout << setw(10) << store.list[loop].inv << endl;		if (line % 10 == 0) cout << endl;		line++;	}}void testSearch (const storeType &store){	int idToFind, invReturn, index;		cout << "Testing search algorithm" << endl << endl;	cout << "Enter Id value to search for (-1 to quit) ---> ";	cin >> idToFind;	while (idToFind >= 0)	{		// index = bsearch (store, idToFind);  // call non-recursive version		index = sequentialSearch (store, idToFind);		cout << "Id # " << idToFind;		if (-1 == index) 			cout << "     No such part in stock" << endl;		else 			cout << "     Inventory = " << store.list[index].inv << endl;		cout << endl << "Enter Id value to search for (-1 to quit) ---> ";		cin >> idToFind;	}}int bsearch (const storeType &store, int idToSearch){	int low=0, high=store.number-1, mid;		while (low <= high)	{		mid = (low + high) / 2;		if (store.list[mid].id == idToSearch)			return mid;		else			if (idToSearch < store.list[mid].id)				high = mid - 1;			else				low = mid + 1;	}	return -1;   // did not find idToSearch}/*int bsearch (const storeType &store, int idToSearch, int first, int last)//	recursive version, searches range from first to last of the vector{	int  mid;	if (last < first)		return -1;	else	{		mid = (first + last) / 2;			if (idToSearch == store.list[mid].id)			return mid;		else			if (idToSearch < store.list[mid].id)				return bsearch (store, idToSearch, first, mid-1);			else				return bsearch (store, idToSearch, mid+1, last);	}}*/void  swap (item &a, item &b){	item temp = a;  a = b;  b = temp;}void quickSort (apvector<item> &list, int first, int last){	int g = first, h = last;	int midIndex;	int dividingValue;	midIndex = (first + last) / 2;	dividingValue = list[midIndex].id;	do	{		while (list[g].id < dividingValue) g++;		while (list[h].id > dividingValue) h--;		if (g <= h)		{			swap(list[g], list[h]);			g++;			h--;		}	}	while (h > g);	if (h > first) quickSort (list,first,h);	if (g < last) quickSort (list,g,last);}int sequentialSearch (const storeType &store, int idToSearch)	// for worksheet problem{	int k, pos = 0;		for (k=0; k<store.number; k++)		if (store.list[k].id == idToSearch)			return k;	return -1;}