// date.h  // Building a date ADT// Last revised, 4/28/97#ifndef date_h_#define date_h_#include <iostream.h>#include <bool.h>class date{	public:		// Lesson 28 material		date ();			// default constructor		date (int month, int day, int year);			// constructor with initial values of month, day, and year		date (const date &temp);			// copy constructor, self is constructed as a copy of temp				void setDate (int month, int day, int year);  // set values for date		void getDate ();  // get date from keyboard		void print () const;   // public print function				// Lesson 29 material		void getDate (istream &);		void print (ostream &) const;		// helper functions to support free functions				// Lesson 30 material		date operator++();		// preincrement		date operator++(int);	// postincrement		date operator--();		// predecrement		date operator--(int);	// postincrement	 	bool operator== (const date&) const;		bool operator!= (const date&) const;		bool operator< (const date&) const;		bool operator> (const date&) const;		bool operator<= (const date&) const;		bool operator>= (const date&) const;			private:		int myMonth, myDay, myYear;		int daysInMonth (int, int);	// private member function};// non-member free functions, support overloaded << and >> for date objects// Lesson 29 materialistream& operator>> (istream &, date &);ostream& operator<< (ostream &, const date &);//  Constructors//  default constructor//  Allows for declaration of date classes//		date  day1, day2;date::date ()			: myMonth(1), myDay(1), myYear(1998){	// all private values initialized using initializer list		}//  constructor with initial values supplied as 3 integers//	 Sample usage://		date  day1 (6,30,96);date::date(int month, int day, int year){	setDate(month,day,year);}//  copy constructor//  Sample usage://		date  day2 (day1);	constructs day2 as a copy of day1date::date(const date& temp)	: myMonth(temp.myMonth), myDay(temp.myDay), myYear(temp.myYear) {	// all private values initialized using initializer list		}// allows user to set a date, using 3 integer valuesvoid date::setDate (int month, int day, int year)// This code will deal with 3 different types of values for the year://		if year ranges from 20..99, its stored as 1920.1999.//    if year = 0, 00, or 2000 then set year to 2000//    if year ranges from 1..19, year is stored as 2001..2019.{			if (year < 0)		year = 1997;	else if ((0 == year) || (2000 == year))		year = 2000;	else if (year <= 19)				year += 2000;	else if ((19 < year) && (year <= 99))	// assume user wants year 1911-1999		year += 1900;	else if (year > 2099)		year = 1997;	if ((month < 1) || (month > 12))		month = 1;	if ( (day > daysInMonth(month, year)) || (day < 1))		day = 1;	myMonth = month;	myDay = day;	myYear = year;}// gets information from keyboard to initialize datevoid date::getDate (){	int  month, day, year;		cin >> month >> day >> year;	setDate (month,day,year);}void date::getDate (istream &infile){	int  month, day, year;		infile >> month >> day >> year;	setDate (month, day, year);}void date::print (ostream &outfile) const{	outfile << myMonth << "/" << myDay << "/";	if (2000 == myYear)		outfile << "00";	else if ((2000 < myYear) && (myYear < 2010)) outfile << "0" << myYear - 2000;	else if ((2010 <= myYear) && (myYear < 2100)) outfile << myYear - 2000;	else outfile << myYear - 1900; }// public print functionvoid date::print () const{	cout << myMonth << "/" << myDay << "/";	if (2000 == myYear)		cout << "00";	else if ((2000 < myYear) && (myYear < 2010)) cout << "0" << myYear - 2000;	else if ((2010 <= myYear) && (myYear < 2100)) cout << myYear - 2000;	else cout << myYear - 1900; }istream& operator>> (istream &infile, date &temp){	temp.getDate (infile);	return infile;}ostream& operator<< (ostream &outfile, const date &temp){	temp.print(outfile);	return outfile;}date date::operator++ (void){	if (myDay == daysInMonth (myMonth, myYear))	{		myDay = 1;		if (12 == myMonth)		{			myMonth = 1;			myYear++;		}		else			myMonth++;	}	else		myDay++;	return *this;}date date::operator++ (int){	date temp = *this;		++(*this);	// use the already defined preincrement operation	return temp;}date date::operator-- (){	if ((1 == myDay) && (1 == myMonth))	{		myMonth = 12;		myDay = 31;		myYear--;	}	else if (1 == myDay)  // and myMonth > 1	{		myMonth--;		myDay = daysInMonth(myMonth,myYear);	}	else  // myDay > 1		myDay--;	return *this;}date date::operator-- (int){	date temp = *this;		--(*this);	return temp;}bool date::operator== (const date &temp) const{	return ((myMonth == temp.myMonth) && (myDay == temp.myDay) &&		 (myYear == temp.myYear));}bool date::operator!= (const date &temp) const{	return !(*this == temp);}bool date::operator< (const date &temp) const{	if (myYear > temp.myYear)		return false;	else if (myYear < temp.myYear)		return true;	else  // same year		if (myMonth > temp.myMonth)			return false;		else if (myMonth < temp.myMonth)			return true;		else  // same year, same month			return (myDay < temp.myDay);}bool date::operator> (const date &temp) const{	return (!(*this == temp) && !(*this < temp));}bool date::operator<= (const date &temp) const{	return ((*this < temp) || (*this == temp));}bool date::operator>= (const date &temp) const{	return ((*this > temp) || (*this == temp));}// private function, returns number of day for month/year valuesint date::daysInMonth(int month, int year){	int days;		switch (month)	{		case 1: case 3: case 5: case 7: case 8: case 10: case 12:			days = 31;			break;		case 4: case 6: case 9: case 11:			days = 30;			break;		case 2:			days = 28;			if (year % 400 == 0)				days = 29;			else if ((year % 4 == 0) && (year % 100 != 0))				days = 29;			break;	}	return days;}#endif