//  ordList.cpp with constructors#include <iostream.h>#include <iomanip.h>#include <fstream.h>#include <bool.h>#include <apstring.h>#include <stdlib.h>const apstring SOURCE = "c:\\ap98\\file20.txt";struct listNode{	int  id, inv;	listNode  *next;	listNode (int tempId, int tempInv, listNode *nxt);	};listNode::listNode (int tempId, int tempInv, listNode *nxt)	: id(tempId), inv(tempInv), next(nxt){	// all values initialized using initializer list}typedef listNode* nodePtr;struct listType{	nodePtr first;	nodePtr last;};	void insertInOrder (listType &, int, int);void insertOutOfOrder (listType &, int, int);nodePtr search (listType, int);bool removeNode (listType &, int);void testSearch (listType);void testDelete (listType &);void clearList (listType &);void printList (listType);int countNodes (listType);void readData (listType &);void printBackward (nodePtr temp);void mainMenu (listType &);main(){	listType list;	list.first = list.last = NULL;	mainMenu (list);	return 0;}void insertInOrder (listType &L, int id, int inv){	nodePtr temp, back;		if (L.first == NULL)		L.first = L.last = new listNode (id, inv, NULL);	else if (id <= L.first->id)	  // place at front of list		L.first = new listNode (id, inv, L.first);	else if (id > L.last->id)	  // place at end of list	{		L.last->next = new listNode (id, inv, NULL);		L.last = L.last->next;	}	//  the above 2 lines can be compressed into 1 line	// L.last = L.last->next = new listNode (id, inv);	else	// general case, insert between two nodes	{		temp = L.first;		while (id > temp->id)		{			back = temp;			temp = temp->next;		}		back->next = new listNode (id, inv, temp);	}}void insertOutOfOrder (listType &L, int id, int inv){	if (NULL == L.first)		L.first = L.last = new listNode(id, inv, L.first);	else	{		L.last->next = new listNode (id, inv, NULL);			L.last = L.last->next;	}}nodePtr search (listType L, int idToFind){	nodePtr temp = L.first;		while ((temp != NULL) && (temp->id != idToFind))		temp = temp->next;	if (temp == NULL)		return NULL;	else		return temp;}bool removeNode (listType &L, int id)// removes node with id value// return true if deletion was successful, otherwise returns false{	nodePtr temp, back, marker;		if (L.first == NULL)		return false;	else	{		if (L.first->id == id)	// delete first node		{			marker = L.first;			if (L.first == L.last)	// deleting 1 node in list case				L.first = L.last = NULL;			else				L.first = L.first->next;			delete marker;			return true;		}		else  // general case		{			temp = L.first;			while ((temp != NULL) && (temp->id != id))			{				back = temp;				temp = temp->next;			}			if (temp != NULL)			{				marker = temp;				back->next = temp->next;				if (temp == L.last)	// deleting last node case					L.last = back;				delete marker;				return true;			}			else				return false;		}	}}		void testSearch (listType temp){	int idToFind;	nodePtr location;		cout << "Testing search algorithm" << endl << endl;	cout << "Enter Id value to search for (-1 to quit) ---> ";	cin >> idToFind;	while (idToFind >= 0)	{		location = search (temp, idToFind);		cout << "Id # " << idToFind;		if (NULL == location) 			cout << "     No such part in stock" << endl;		else 			cout << "     Inventory = " << location->inv << endl;		cout << endl << "Enter Id value to search for (-1 to quit) ---> ";		cin >> idToFind;	}}void testDelete (listType &temp){	int idToDelete;	bool success;		cout << "Testing delete algorithm" << endl << endl;	cout << "Enter Id value to delete (-1 to quit) ---> ";	cin >> idToDelete;	while (idToDelete >= 0)	{		success = removeNode (temp, idToDelete);		cout << "Id # " << idToDelete;		if (!success) 			cout << "     No such part in stock" << endl;		else 			cout << "     Id #" << idToDelete << " was deleted" << endl;		cout << endl << "Enter Id value to delete (-1 to quit) ---> ";		cin >> idToDelete;	}}void clearList (listType &local){	nodePtr temp, back;		if (local.first != NULL)	// something to dispose	{		temp = local.first;		while (temp != NULL)		{			back = temp;			temp = temp->next;			delete back;		}		local.first = local.last = NULL;	}}void printList (listType local){	nodePtr temp = local.first;	int line = 1;		cout << setiosflags (ios::right);	cout << setw(15) << "Id" << setw(10) << "Inv" << endl << endl;	while (temp != NULL)	{		cout << setw(5) << line << setw(10) << temp->id << setw(10) << temp->inv << endl;		if (line % 10 == 0) cout << endl;		temp = temp->next;		line++;	}	cout << endl;}int countNodes (listType local){	nodePtr temp = local.first;	int count = 0;		while (temp != NULL)	{		count++;		temp = temp->next;	}	return count;}void readData (listType &temp){	ifstream inFile;	int howMany, k, id, inv;	inFile.open(SOURCE.c_str());	if (inFile.fail())	{		cerr << "Could not open " << SOURCE << endl;		abort();	}	inFile >> howMany;	for (k=1; k<=howMany; k++)	{		inFile >> id >> inv;		insertInOrder (temp, id, inv);	}}void printBackward (nodePtr temp){	if (NULL != temp)	{		printBackward (temp->next);		cout << setw(10) << temp->id << setw(10) << temp->inv << endl;	}}void mainMenu (listType &temp){	char choice, print;	do	{		cout << "Linked List algorithm menu" << endl << endl;		cout << "(1) Read file10.txt from disk" << endl;		cout << "(2) Print ordered list" << endl;		cout << "(3) Search list" << endl;		cout << "(4) Delete from list" << endl;		cout << "(5) Clear entire list" << endl;		cout << "(6) Count nodes in list" << endl;		cout << "(7) Print list backwards" << endl;		cout << "(8) Quit" << endl << endl;		cout << "Choice ---> ";		cin >> choice;		cin.get();	// to dump return key		cout << endl;		if ('1'<=choice && choice<='7')		{			switch (choice)			{				case '1' : readData(temp); break;				case '2' : printList(temp); break;				case '3' : testSearch(temp); break;				case '4' : testDelete(temp); break;				case '5' : clearList(temp); break;				case '6' :					cout << "Number of nodes = " << countNodes (temp) << endl << endl;					break;				case '7' : 					cout << setw(10) << "Id" << setw(10) << "Inv" << endl << endl;					if (countNodes(temp) <= 50)						printBackward(temp.first); 					else						cout << "List is too long to print recursively" << endl;					break;			}		}	}	while (choice != '8');}