// mergeList.cpp/* This program will test a recursive mergesort implemented using linked lists.	The sequence of events:		1.  Read file20.txt, build the list unordered as it comes off the data file.		2.  Print the list, unordered.		3.  Sort the list using a recursive mergesort.		4.  Print the list again;  it should now be sorted.		5.  Reverse the list.		6.  Print the list a third time;  it should now be in descending order  */		#include <iostream.h>#include <iomanip.h>#include <fstream.h>#include <apstring.h>#include <stdlib.h>const apstring SOURCE = "c:\\ap98\\file20.txt";struct listNode{	int  id, inv;	listNode  *next;	listNode (int tempId, int tempInv, listNode *tempNext);};listNode::listNode (int tempId, int tempInv, listNode *tempNext)	: id(tempId), inv(tempInv), next(tempNext){	// all values initialized using initializer list}typedef listNode *ptr;void printList (ptr);void readData (ptr &);void split (ptr &, ptr &);void merge (ptr &, ptr);void mergeSort (ptr &);void reverseList (ptr &);main(){	ptr list;		readData (list);	printList (list);	mergeSort (list);	printList (list);	reverseList (list);	printList (list);	return 0;}void printList (ptr temp){	int line = 0;	cout << setiosflags (ios::right);	cout << setw(15) << "Id" << setw(10) << "Inv" << endl << endl;	while (temp != NULL)	{		line++;		cout << setw(5) << line << setw(10) << temp->id << setw(10) << temp->inv << endl;		if (line % 10 == 0) cout << endl;		temp = temp->next;	}}void readData (ptr &temp){	ifstream inFile;	int howMany, k, id, inv;	inFile.open(SOURCE.c_str());	if (inFile.fail())	{		cerr << "Could not open " << SOURCE << endl;		abort();	}	temp = NULL;	inFile >> howMany;	for (k=1; k<=howMany; k++)	{		inFile >> id >> inv;		temp = new listNode (id, inv, temp);	}}void split (ptr &a, ptr &b)/* The list originally represented by  a  is split into two lists, a and b,   who's lengths differ by no more than 1 node. */{	int k, count = 0, half;	ptr temp = a;		while (temp != NULL)	{		count++;		temp = temp->next;	}	half = (count/2)-1;	// go to middle, less 1	temp = a;	for (k=1; k<=half; k++)		temp = temp->next;	b = temp->next;	// break off list b	temp->next = NULL;  // NULL terminate list a}void merge (ptr &a, ptr b)// merges list a and b in ascending order by id value{	ptr  aptr, bptr, last;		if (NULL == b);		// return a unchanged	else	{		if (NULL == a)  			a = b;		else			// general case		{			aptr = a;			bptr = b;			if (aptr->id < bptr->id)			{				// no change in starting position of list a				aptr = aptr->next;			}			else			{				a = b;				bptr = bptr->next;			}			last = a;		// keeps track of the last node in the new list, pointed to by a						while ((NULL != aptr) || (NULL != bptr))	// need or operator			{				if (NULL == aptr)	// pull from list b				{					last->next = bptr;					bptr = bptr->next;				}				else if (NULL == bptr)	// pull from list a				{					last->next = aptr;					aptr = aptr->next;				}				else if (aptr->id < bptr->id)				{					last->next = aptr;					aptr = aptr->next;				}				else				{					last->next = bptr;					bptr = bptr->next;				}				last = last->next;			}			last->next = NULL;		}	// general case	}		}	void mergeSort (ptr &a){	ptr b;		if (NULL == a);		// base case	else		if (NULL == a->next);		// base case, list of 1 node		else		{			split (a,b);			mergeSort (a);			mergeSort (b);			merge (a,b);		}}void reverseList (ptr &head)//  Takes in linked list pointed to by head, reverses order of nodes.{	ptr  back, temp = head;		if (head != NULL)		// a list of 1 node exists	{		temp = temp->next;	// move temp to 2nd node, or NULL		head->next = NULL;	// begin new list, break off of main list		while (NULL != temp)		{			back = temp;			// set back to leftmost node in old list			temp = temp->next;	// move temp to second node or NULL in old list			back->next = head;	// attach leftmost node into new list			head = back;			// set head pointing to newest node of new list		}	}}