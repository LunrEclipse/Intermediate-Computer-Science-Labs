//  double.cpp#include <iostream.h>#include <iomanip.h>#include <fstream.h>#include <bool.h>#include <apstring.h>#include <stdlib.h>const apstring SOURCE = "c:\\ap98\\file10.txt";struct listNode{	int  id, inv;	listNode  *right;	listNode  *left;	listNode (int tempId, int tempInv, 				listNode *tempLeft, listNode *tempRight);};listNode::listNode (int tempId, int tempInv,                     listNode *tempLeft, listNode *tempRight)	: id(tempId), inv(tempInv), left(tempLeft), right(tempRight){	// all values initialized in initializer list}typedef listNode* nodePtr;struct listType{	nodePtr first;	nodePtr last;};	void insertInOrder (listType &, int, int);nodePtr search (listType, int);bool removeNode (listType &, int);void testDelete (listType &);void printListForward (listType);int countNodes (listType);void readData (listType &);void printListBackward (listType);void mainMenu (listType &);main(){	listType list;		list.first = list.last = NULL;		// defines an empty list	mainMenu (list);	return 0;}void insertInOrder (listType &L, int id, int inv){	nodePtr temp, back;		if (L.first == NULL)		L.first = L.last = new listNode (id, inv, NULL, NULL);	else if (id < L.first->id)	  // place at front of list	{		temp = L.first;		L.first = new listNode (id, inv, NULL, temp);		temp->left = L.first;	}	else if (id > L.last->id)	  // place at end of list	{		L.last->right = new listNode (id, inv, L.last, NULL);		L.last = L.last->right;	}	else	// general case, insert between two nodes	{		temp = L.first;		while (id > temp->id)		{			back = temp;			temp = temp->right;		}		back->right = new listNode (id,inv,back,temp);		temp->left = back->right;	}}bool removeNode (listType &L, int id)// removes node with id value// return true if deletion was successful, otherwise returns false{	nodePtr temp, back, marker;	if (L.first == NULL)		return false;	else	{		if (L.first->id == id)	// delete first node		{			marker = L.first;			if (L.first == L.last)	// special case, deletion of 1 node				L.first = L.last = NULL;			else			{				L.first = L.first->right;				L.first->left = NULL;			}			delete marker;			return true;		}		else  // general case		{			temp = L.first;			while ((temp != NULL) && (temp->id != id))			{				back = temp;				temp = temp->right;			}			if (temp != NULL)		// found a node to delete			{				marker = temp;				temp=temp->right;				back->right = temp;				if (NULL == temp)					L.last = back;				else					temp->left = back;				delete marker;				return true;			}			else				return false;		}	}}		void testDelete (listType &temp){	int idToDelete;	bool success;		cout << "Testing delete algorithm" << endl << endl;	cout << "Enter Id value to delete (-1 to quit) ---> ";	cin >> idToDelete;	while (idToDelete >= 0)	{		success = removeNode (temp, idToDelete);		cout << "Id # " << idToDelete;		if (!success) 			cout << "     No such part in stock" << endl;		else 			cout << "     Id #" << idToDelete << " was deleted" << endl;		cout << endl << "Enter Id value to delete (-1 to quit) ---> ";		cin >> idToDelete;	}}void printListForward (listType local){	nodePtr temp = local.first;	int line = 1;		cout << setiosflags (ios::right);	cout << setw(15) << "Id" << setw(10) << "Inv" << endl << endl;	while (temp != NULL)	{		cout << setw(5) << line << setw(10) << temp->id << setw(10) << temp->inv << endl;		if (line % 10 == 0) cout << endl;		temp = temp->right;		line++;	}	cout << endl;}void printListBackward (listType local){	nodePtr temp = local.last;	int line = 1;		cout << setiosflags (ios::right);	cout << setw(15) << "Id" << setw(10) << "Inv" << endl << endl;	while (temp != NULL)	{		cout << setw(5) << line << setw(10) << temp->id << setw(10) << temp->inv << endl;		if (line % 10 == 0) cout << endl;		temp = temp->left;		line++;	}	cout << endl;}int countNodes (listType local){	nodePtr temp = local.first;	int count = 0;		while (temp != NULL)	{		count++;		temp = temp->right;	}	return count;}void readData (listType &temp){	ifstream inFile;	int howMany, k, id, inv;	inFile.open(SOURCE.c_str());	if (inFile.fail())	{		cerr << "Could not open " << SOURCE << endl;		abort();	}		inFile >> howMany;	for (k=1; k<=howMany; k++)	{		inFile >> id >> inv;		insertInOrder (temp, id, inv);	}}void mainMenu (listType &temp){	char choice, print;	do	{		cout << "Doubly-Linked List algorithm menu" << endl << endl;		cout << "(1) Read file10.txt from disk" << endl;		cout << "(2) Print list forward" << endl;		cout << "(3) Print list backwards" << endl;		cout << "(4) Count nodes in list" << endl;		cout << "(5) Delete from list" << endl;		cout << "(6) Quit" << endl << endl;		cout << "Choice ---> ";		cin >> choice;		cin.get();	// to dump return key		cout << endl;		if ('1'<=choice && choice<='5')		{			switch (choice)			{				case '1' : readData(temp); break;				case '2' : printListForward(temp); break;				case '3' : printListBackward(temp); break;				case '4' :					cout << "Number of nodes = " << countNodes (temp) << endl << endl;					break;				case '5' : testDelete(temp); break;			}		}	}	while (choice != '6');}