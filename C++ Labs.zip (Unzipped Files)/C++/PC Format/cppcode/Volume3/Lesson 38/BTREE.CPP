//  bTree.cpp//  Binary tree lab, Lesson 36-38#include <iostream.h>#include <iomanip.h>#include <fstream.h>#include <iomanip.h>#include <bool.h>#include <apstring.h>#include <stdlib.h>const apstring FILENAME = "c:\\ap98\\file10.txt";struct treeNode{	int  id, inv;	treeNode  *left, *right;		treeNode (int, int, treeNode *, treeNode *);};treeNode::treeNode (int tempId, int tempInv, treeNode *tempLeft, treeNode *tempRight)	: id (tempId), inv(tempInv), left(tempLeft), right(tempRight){	// all values initialized using initializer list}typedef treeNode* treePtr;void insert (treePtr &temp, int id, int inv);treePtr search (treePtr, int);void testSearch (treePtr);void testDelete (treePtr &);void inorder (treePtr);int countNodes (treePtr);void modifyTree (treePtr &);bool deleteNode (treePtr &, int);void readData (treePtr &);void mainMenu (treePtr &);main(){	treePtr root;		root = NULL;	mainMenu (root);	return 0;}void insert (treePtr &temp, int id, int inv){	if (NULL == temp)		temp = new treeNode (id, inv, NULL, NULL);	else		if (id < temp->id)			insert (temp->left, id, inv);		else			insert (temp->right, id, inv);}treePtr search (treePtr temp, int idToFind){	if (NULL == temp) return NULL;	else		if (idToFind == temp->id)			return temp;		else			if (idToFind < temp->id)				return search (temp->left, idToFind);			else				return search (temp->right, idToFind); }		void testSearch (treePtr temp){	int idToFind;	treePtr location;		cout << "Testing search algorithm" << endl << endl;	cout << "Enter Id value to search for (-1 to quit) ---> ";	cin >> idToFind;	while (idToFind >= 0)	{		location = search (temp, idToFind);		cout << "Id # " << idToFind;		if (NULL == location) 			cout << "     No such part in stock" << endl;		else 			cout << "     Inventory = " << location->inv << endl;		cout << endl << "Enter Id value to search for (-1 to quit) ---> ";		cin >> idToFind;	}}void testDelete (treePtr &temp){	int idToDelete;	bool success;		cout << "Testing delete algorithm" << endl << endl;	cout << "Enter Id value to delete (-1 to quit) ---> ";	cin >> idToDelete;	while (idToDelete >= 0)	{		success = deleteNode (temp, idToDelete);		cout << "Id # " << idToDelete;		if (!success)			cout << "     No such part in stock" << endl;		else 			cout << "     Id #" << idToDelete << " was deleted" << endl;		cout << endl << "Enter Id value to delete (-1 to quit) ---> ";		cin >> idToDelete;	}}void inorder (treePtr temp){	if (temp != NULL)	{		inorder (temp->left);		cout << setw(10) << temp->id << setw(10) << temp->inv << endl;		inorder (temp->right);	}}int countNodes (treePtr temp){	if (NULL == temp) return 0;	else return  countNodes (temp->left) + 1 + countNodes (temp->right);}void readData (treePtr &temp){		ifstream inFile;	int howMany, k, id, inv;		inFile.open(FILENAME.c_str());	if (inFile.fail())	{		cerr << "Could not open " << FILENAME << endl;		abort();	}	inFile >> howMany;	for (k=1; k<=howMany; k++)	{		inFile >> id >> inv;		insert (temp, id, inv);	}}void modifyTree (treePtr &p)// p is either root or an internal pointer in the tree// Algorithm deletes node pointed to by p.{	treePtr temp, marker = p;		if ((NULL == p->right) && (NULL == p->left))		// leaf case		p = NULL;	else if (NULL == p->right)  // one-kid case, re-hook p to left child		p = p->left;	else if (NULL == p->left)	// other one-kid case, re-hook p to right child		p = p->right;	else	// 2-kid case	{		p = p->left;	// re-route pointer around node to be deleted		temp = p;		while (temp->right != NULL)			temp = temp->right;		// find new attachment point		temp->right = marker->right;	// re-hook branch	}	delete marker;}		bool deleteNode (treePtr &p, int idToDelete)// will recursively search for node with idToDelete, if found, calls modifyTree{	if (NULL == p)  return false;	else if (idToDelete == p->id)	{		modifyTree (p);		return true;	}	else if (idToDelete < p->id)		return deleteNode(p->left, idToDelete);	else		return deleteNode (p->right, idToDelete);}	void mainMenu (treePtr &root){	char choice;		cout << setiosflags (ios::right);	do	{		cout << "Binary tree menu" << endl << endl;		cout << "(1) Read " << FILENAME << " from disk" << endl;		cout << "(2) Print tree inorder" << endl;		cout << "(3) Search tree" << endl;		cout << "(4) Delete from tree" << endl;		cout << "(5) Count nodes in tree" << endl;		cout << "(6) Quit" << endl << endl;		cout << "Choice ---> ";		cin >> choice;		cin.get();	// to dump return key		cout << endl;		if ('1'<=choice && choice<='5')		{			switch (choice)			{				case '1' : readData(root); break;				case '2' : 					cout << endl << "The tree printed inorder" << endl << endl;					cout << setw(10) << "Id" << setw(10) << "Inv" << endl;					inorder (root);					cout << endl;					break;				case '3' : testSearch(root); break;				case '4' : testDelete(root); break;				case '5' :					cout << "Number of nodes = " << countNodes (root) << endl << endl;					break;			}		}	}	while (choice != '6');}