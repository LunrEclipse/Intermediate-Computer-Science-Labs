// newstack.h#ifndef _newstack_h#define _newstack_h#include <iostream.h>#include <bool.h>#include <stdlib.h>template <class itemType>class apstack{	public:		apstack();	// empty stack constructor		apstack(const apstack & s);  // copy constructor		~apstack();	 // destructor				const apstack & operator= (const apstack & rhs);	// assignment				const itemType & top()	const;	// return top element with no pop		bool isEmpty() const;	// if empty return true, else false		int  length() const;	   // return number of elements in stack				void push(const itemType & item);	// push item onto top of stack		void pop();		// pop top element		void pop(itemType &item);	  // pop and top 		void makeEmpty();		// make stack empty			private:		struct stackNode		{			itemType  myItem;			stackNode  *next;						stackNode (itemType MyItem, stackNode *Next)				: myItem(MyItem), next(Next)			{			}		};		typedef stackNode* stackPtr;				stackPtr myStack;};template<class itemType>		// default constructorapstack<itemType>::apstack(){	myStack = NULL;}template<class itemType>		// copy constructorapstack<itemType>::apstack(const apstack & s){	if (this != &s)	{		myStack = NULL;	// set to NULL because (=) checks for NULL		*this = s;		// uses overloaded = operator		}}template<class itemType>		// destructorapstack<itemType>::~apstack(){	makeEmpty();}template<class itemType>		// assignmentconst apstack<itemType> &apstack<itemType>::operator= (const apstack<itemType> & rhs){	stackPtr temp, tail;		if (this != &rhs)	{		makeEmpty();		// after makeEmpty(), myStack = NULL		if (rhs.myStack != NULL)		// is there a stack to copy?		{			temp = rhs.myStack;			myStack = new stackNode(temp->myItem, NULL);  			tail = myStack;	// tail will point to the last node in the growing stack			temp = temp->next;  // traverses old stack			while (temp != NULL)			{				tail->next = new stackNode(temp->myItem, NULL);				tail = tail->next;				temp = temp->next;			}			}	}	return *this;}template<class itemType>		// return top elementconst itemType &apstack<itemType>::top() const{	if (isEmpty())	{		cerr << "cannot top an empty stack";		abort();	}	return myStack->myItem;}template<class itemType>		// isEmptyboolapstack<itemType>::isEmpty() const{	return (NULL == myStack);}template<class itemType>		// lengthintapstack<itemType>::length() const{	int n=0;	stackNode *temp = myStack;		while (temp != NULL)	{		n++;		temp = temp->next;	}	return n;}template<class itemType>		// push new item onto stackvoid apstack<itemType>::push(const itemType &item){	myStack = new stackNode (item,myStack);}template<class itemType>		// pop stack, no returnvoidapstack<itemType>::pop()	{	if (isEmpty())	{		cerr << "error, popping an empty stack";		abort();	}	else	{		stackNode *temp = myStack;		myStack = myStack->next;		delete temp;	}}template <class itemType>		// pop and top, returns itemvoidapstack<itemType>::pop(itemType &item){	if (isEmpty())	{		cerr << "error, popping an empty stack";		abort();	}	else	{		stackNode *temp = myStack;		item = myStack->myItem;		myStack = myStack->next;		delete temp;	}}template <class itemType>voidapstack<itemType>::makeEmpty(){	stackPtr temp = myStack;		while (myStack != NULL)	{		myStack = myStack->next;		delete temp;		temp = myStack;	}}	#endif