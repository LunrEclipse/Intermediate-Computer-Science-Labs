// hashing.cpp#include <iostream.h>#include <fstream.h>#include <apvector.h>#include <iomanip.h>#include <apstring.h>#include <stdlib.h>const int TABLESIZE = 600;const apstring FILENAME = "c:\\ap98\\file400.txt";struct listNode{	int myId;	int myInv;	listNode* next;		listNode (int, int, listNode*);};listNode::listNode (int tempId, int tempInv, listNode *tempNext)	: myId(tempId), myInv(tempInv), next(tempNext){	// all values initialized using initializer list}typedef listNode* listPtr;typedef apvector<listPtr> hashTable; int hash (long);void insert (hashTable &, int, int);void loadFile (hashTable &, int &);int hashSearch (const hashTable &, int);void testSearch (const hashTable &);int numberOfNulls (const hashTable &);int longestList (const hashTable &);void stats (const hashTable &, int);main(){	hashTable table(TABLESIZE,NULL);	int number;		loadFile(table,number);	testSearch(table);	stats (table,number);	return 0;}int hash (long keyId)// takes in keyId, returns a location in the hash table, 0 .. (TABLESIZE-1)// function uses long integers to avoid problems with integer overflow{	const int MODULUS = 1999;	// a large prime number	const int MULTIPLIER = 273;	const int INCREMENT = 59;	long temp;		temp = (MULTIPLIER * keyId) + INCREMENT;	temp = temp % MODULUS;	temp = temp % TABLESIZE;	return temp;}void insert (hashTable &table, int id, int inv)// calls hash to find location of where to insert id/inv into table{	int location = hash(id);	table[location] = new listNode (id, inv, table[location]);}void loadFile (hashTable &table, int &number){	ifstream inFile;	int k, id, inv;		inFile.open(FILENAME.c_str());	if (inFile.fail())	{		cerr << "Could not open " << FILENAME << endl;		abort();	}		inFile >> number;	for (k=1; k<=number; k++)	{		inFile >> id >> inv;		insert (table, id, inv);	}}int hashSearch (const hashTable &table, int idToFind)// will attempt to find idToFind in table, if found return inv amount,// else return -1{	int location;	listPtr temp;		location = hash(idToFind);	temp = table[location];	while ((temp != NULL) && (idToFind != temp->myId))		temp = temp->next;	if (NULL == temp)		return -1;	else		return temp->myInv;} void testSearch (const hashTable &table){	int idToFind, invReturned;		cout << "Testing search algorithm" << endl << endl;	cout << "Enter Id value to search for (-1 to quit) ---> ";	cin >> idToFind;	while (idToFind >= 0)	{		invReturned = hashSearch (table, idToFind);		cout << "Id # " << idToFind;		if (-1 == invReturned) 			cout << "     No such part in stock" << endl;		else 			cout << "     Inventory = " << invReturned << endl;		cout << endl << "Enter Id value to search for (-1 to quit) ---> ";		cin >> idToFind;	}}int numberOfNulls (const hashTable &table){	int count = 0, k;		for (k=0; k<TABLESIZE; k++)		if (NULL == table[k])			count++;	return count;}	int longestList (const hashTable &table){	int longest=0, k, length;	listPtr temp;		for (k=0; k<TABLESIZE; k++)	{		length = 0;		temp = table[k];		while (temp != NULL)		{			length++;			temp = temp->next;		}		if (length > longest)			longest = length;	}	return longest;}			void stats (const hashTable &table, int number)// will print out required stats for this lab{	int emptySpots;	double avgListLen;		cout << setprecision (2) << setiosflags (ios::fixed);	emptySpots = numberOfNulls (table);	cout << "Number of NULLs = " << emptySpots << endl;	cout << "% of NULL pointers = " << double(emptySpots)*100/TABLESIZE << " %" << endl;	avgListLen = double(number)/(TABLESIZE - emptySpots);	cout << "Average list length = " << avgListLen << endl;	cout << "The longest list = " << longestList(table) << endl;}